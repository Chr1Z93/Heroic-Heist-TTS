require("CardMetadata")
local searchLib = require("libraries/SearchLib")

GridStart = {
  Blue = { row = 1, col = 3 },
  Red  = { row = 5, col = 3 }
}

direction = { Blue = -1, Red = 1 }

NOT_INTERACTABLE = {
  "PlayArea",
  "PlayAreaBlue",
  "PlayAreaRed",
  "HighlightBoardBlue",
  "HighlightBoardRed"
}

GUID_LIST = {
  DeckmatBlue           = "ea89a6",
  DeckmatRed            = "42d92c",
  GamePanel             = "2f5ddb",
  HealthTrackerBlue     = "29b826",
  HealthTrackerRed      = "5a08bb",
  HiddenZoneBlue        = "9ed505",
  HiddenZoneRed         = "06ee50",
  HighlightBoardBlue    = "5ef1df",
  HighlightBoardRed     = "7ef1df",
  PlayArea              = "5ef1de",
  PlayAreaBlue          = "76b598",
  PlayAreaRed           = "7e4f92",
  PlayermatBlue         = "1f4fe0",
  PlayermatRed          = "9c3ece",
  RoundTracker          = "bbd4df",
  ScoreTrackerBlue      = "aba675",
  ScoreTrackerRed       = "bf8e2e",
  SourcePlayerTokenBlue = "fc5ff4",
  SourcePlayerTokenRed  = "81eaa5",
  SourceRelic           = "1e886d",
  SourceAttackDeck      = "893ba7",
  SourceMovementDeck    = "f8b297",
  SourceExplosion       = "b2b73f",
  TurnTracker           = "6707f1",
}

choices = {}

function onSave()
  return JSON.encode({ guids = GUID_LIST })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData = JSON.decode(savedData)
    GUID_LIST = loadedData.guids
  end

  math.randomseed(os.time())
  getReferences()
  setNotInteractable()
  buttonCreationGP()

  -- store explosion data
  explosionData = _G["SourceExplosion"].getData().ContainedObjects[1]
end

-- grab object references
function getReferences()
  for name, guid in pairs(GUID_LIST) do
    _G[name] = getObjectFromGUID(guid)
  end
end

function setNotInteractable()
  for _, name in ipairs(NOT_INTERACTABLE) do
    _G[name].interactable = false
  end
end

-- create buttons on the game panel
function buttonCreationGP()
  -- shared parameters
  local buttonParameters = {
    function_owner = Global,
    position = { x = 0, y = 0.2, z = 0 },
    height = 1350,
    width = 6000,
    scale = { 0.1, 0.1, 0.1 },
    font_size = 1000,
    font_color = { 0, 0, 0 }
  }

  -- new game button
  buttonParameters.label = "New Game"
  buttonParameters.click_function = "newGame"
  buttonParameters.position.z = -0.6
  buttonParameters.tooltip = "Click to start a new game"
  _G["GamePanel"].createButton(buttonParameters)

  -- next round button
  buttonParameters.label = "Next Round"
  buttonParameters.click_function = "nextRound"
  buttonParameters.tooltip = "Click to proceed to the next round"
  buttonParameters.position.z = 0
  _G["GamePanel"].createButton(buttonParameters)

  -- next turn button
  buttonParameters.label = "Next Turn"
  buttonParameters.click_function = "nextTurn"
  buttonParameters.tooltip = "Click to proceed to the next turn"
  buttonParameters.position.z = 0.6
  _G["GamePanel"].createButton(buttonParameters)
end

-- don't allow rotating cards in hands
function onPlayerAction(player, action, targets)
  if action == Player.Action.RotateIncrementalLeft or action == Player.Action.RotateIncrementalRight then
    for _, obj in ipairs(targets) do
      if obj.type == "Card" or obj.type == "Deck" then
        broadcastToColor("Rotating cards is disabled to avoid confusing cards.", player.color, "White")
        return false
      end
    end
  end
  return true
end

-- grid goes from bottom left to top right (from 1/1 to 5/5)
-- x from roughly local -0.6 to +0.6
-- z from roughly local -0.6 to +0.6
function convertPosToGrid(pos)
  local lPos = _G["PlayArea"].positionToLocal(pos)
  local col = math.floor(lPos.x / 0.3 + 0.5) + 3
  local row = math.floor(lPos.z / 0.3 + 0.5) + 3
  return { row = row, col = col }
end

-- find close snap point position
function convertGridToPos(grid)
  local pos = { x = (grid.col - 3) * 0.3, z = (grid.row - 3) * 0.3 }
  for _, snap in ipairs(_G["PlayArea"].getSnapPoints()) do
    if math.abs(snap.position.x - pos.x) < 0.1 and math.abs(snap.position.z - pos.z) < 0.1 then
      return _G["PlayArea"].positionToWorld(Vector(snap.position.x, 0.2, snap.position.z))
    end
  end
end

function takeControlOfRelic(newOwner, move)
  local currentGrid = convertPosToGrid(_G["Relic"].getPosition())

  local currentOwner = nil
  if currentGrid.row == 0 then
    currentOwner = "Blue"
  elseif currentGrid.row == 6 then
    currentOwner = "Red"
  end

  -- take control if uncontrolled + moving or if controlled by other player
  if (currentOwner and currentOwner ~= newOwner) or
      (currentOwner == nil and move == true) then
    local newPos = { 0, 2.8, -15.13 }
    local newRot = { 0, 180, 0 }
    if newOwner == "Red" then
      newPos = { 0, 2.8, 14.45 }
      newRot = { 0, 0, 0 }
    end
    local reason = move and "a movement card)." or "an attack card)."
    broadcastToAll(getColoredName(newOwner) .. " took control of the relic (because of " .. reason, "White")
    _G["Relic"].setPositionSmooth(newPos)
    coWait(1)
    _G["Relic"].setRotation(newRot)
    syncPrivateBoards()
  end
end

function getTargetsForCardId(params)
  local playerColor = params.playerColor
  local cardId = params.cardId
  local md = METADATA[cardId]

  -- get current position of player token
  local grid = convertPosToGrid(_G["PlayerToken" .. playerColor].getPosition())

  -- get target locations
  local mult = -1 * direction[playerColor]
  local targetGridList = {}

  -- add single spots for areas (these are connected)
  for _, data in ipairs(md.targetAreas or {}) do
    -- increase by 5 to avoid negative numbers
    local start1 = data.c1[1] + 5
    local end1 = data.c2[1] + 5
    local start2 = data.c1[2] + 5
    local end2 = data.c2[2] + 5
    local step1 = (start1 >= end1) and -1 or 1
    local step2 = (start2 >= end2) and -1 or 1

    -- get rotation for connected space attacking
    local rot = 0
    if start1 == end1 then
      rot = 90
    elseif start2 == end2 then
      rot = 180
    end

    for i = start1, end1, step1 do
      for j = start2, end2, step2 do
        local newTarget = {
          row = grid.row + (j - 5) * mult,
          col = grid.col + (i - 5) * mult,
          connected = true,
          rot = rot
        }

        -- get potential 2nd rotation for corners
        if ((i == start1 or i == end1) and start1 ~= end1) or ((j == start2 or j == end2) and start2 ~= end2) then
          newTarget.rot2 = newTarget.rot + 90
        end

        if validateTarget(newTarget, false, playerColor) then
          table.insert(targetGridList, newTarget)
        end
      end
    end
  end

  -- add single spots
  for _, data in ipairs(md.targetSpots or {}) do
    local newTarget = {
      row = grid.row + data[2] * mult,
      col = grid.col + data[1] * mult
    }
    if validateTarget(newTarget, false, playerColor) then
      table.insert(targetGridList, newTarget)
    end
  end

  -- add spots for connectiongroups (these are connected)
  for _, outerData in ipairs(md.targetConnectionGroups or {}) do
    for _, data in ipairs(outerData or {}) do
      local newTarget = {
        row = grid.row + data.point[2] * mult,
        col = grid.col + data.point[1] * mult,
        connected = true,
        rot = data.rot,
        rot2 = data.rot2
      }
      if validateTarget(newTarget, false, playerColor) then
        table.insert(targetGridList, newTarget)
      end
    end
  end

  for _, data in ipairs(md.fixedMove or {}) do
    local newTarget = {
      row = grid.row + data[2] * mult,
      col = grid.col + data[1] * mult
    }
    if validateTarget(newTarget, true, playerColor) then
      table.insert(targetGridList, newTarget)
    end
  end

  -- only display close locations for directions
  for _, data in ipairs(md.directionMove or {}) do
    local newTarget = {
      row = grid.row + data[2] * mult,
      col = grid.col + data[1] * mult
    }
    if validateTarget(newTarget, true, playerColor, true) then
      table.insert(targetGridList, newTarget)
    end
  end

  for _, data in ipairs(md.choice1 or {}) do
    local newGrid = {
      row = grid.row + data[2] * mult,
      col = grid.col + data[1] * mult
    }
    if not validateTarget(newGrid, true, playerColor) then
      break
    else
      for _, data2 in ipairs(md.choice2 or {}) do
        local newTarget = {
          row = newGrid.row + data2[2] * mult,
          col = newGrid.col + data2[1] * mult
        }
        if validateTarget(newTarget, true, playerColor) then
          table.insert(targetGridList, newTarget)
        end
      end
    end
  end

  return targetGridList
end

function validateTarget(targetGrid, isMove, playerColor, noBlock)
  if targetGrid.row > 0 and targetGrid.row < 6 and targetGrid.col > 0 and targetGrid.col < 6 then
    if not isMove then
      return true
    else
      -- skip blocking for large arrow movement
      if noBlock then
        return true
      end

      -- get enemy position and check if he blocks
      local enemyColor = oppositeColor(playerColor)
      local grid = convertPosToGrid(_G["PlayerToken" .. enemyColor].getPosition())
      if not grid then
        return false
      end

      if targetGrid.row == grid.row and targetGrid.col == grid.col then
        return false
      else
        return true
      end
    end
  else
    return false
  end
end

function getConnectedTargets(cardId, playerColor, startGrid)
  local connectedTargets = {}
  local md = METADATA[cardId]
  local addedStartGrid = false

  -- get current position of player token
  local grid = convertPosToGrid(_G["PlayerToken" .. playerColor].getPosition())

  -- get target locations
  local mult = -1 * direction[playerColor]

  -- go through targetAreas
  for _, data in ipairs(md.targetAreas or {}) do
    local match = false
    local tempList = {}

    -- increase by 5 to avoid negative numbers
    local start1 = data.c1[1] + 5
    local end1 = data.c2[1] + 5
    local start2 = data.c1[2] + 5
    local end2 = data.c2[2] + 5
    local step1 = (start1 >= end1) and -1 or 1
    local step2 = (start2 >= end2) and -1 or 1

    for i = start1, end1, step1 do
      for j = start2, end2, step2 do
        local newTarget = { row = grid.row + (j - 5) * mult, col = grid.col + (i - 5) * mult }
        table.insert(tempList, newTarget)

        -- check if this is startGrid
        if newTarget.row == startGrid.row and newTarget.col == startGrid.col then
          match = true
        end
      end
    end

    -- if startGrid was contained in this set, add them all to the table
    if match then
      addedStartGrid = true
      for _, target in ipairs(tempList) do
        table.insert(connectedTargets, target)
      end
    end
  end

  -- go through connection groups
  for _, outerData in ipairs(md.targetConnectionGroups or {}) do
    local match = false
    local tempList = {}

    for _, data in ipairs(outerData or {}) do
      local newTarget = { row = grid.row + data.point[2] * mult, col = grid.col + data.point[1] * mult }
      table.insert(tempList, newTarget)

      -- check if this is startGrid
      if newTarget.row == startGrid.row and newTarget.col == startGrid.col then
        match = true
      end
    end

    -- if startGrid was contained in this set, add them all to the table
    if match then
      addedStartGrid = true
      for _, target in ipairs(tempList) do
        table.insert(connectedTargets, target)
      end
    end
  end

  -- if startGrid is not added to the list yet, add it now
  if not addedStartGrid then
    table.insert(connectedTargets, startGrid)
  end

  return connectedTargets
end

-- display a button for each target location
function displayTargetSelection(params)
  local playerColor = params.playerColor
  local cardId = params.cardId
  local targetGridList = getTargetsForCardId(params)

  _G["HighlightBoard" .. playerColor].call("hideAll", playerColor)

  if #targetGridList == 0 then
    broadcastToColor("No valid target locations detected.", playerColor, "Orange")
  else
    for _, targetGrid in ipairs(targetGridList) do
      local hParams = {
        playerColor = playerColor,
        targetGrid = targetGrid,
        cardId = cardId,
        grid = convertPosToGrid(_G["PlayerToken" .. playerColor].getPosition())
      }
      _G["HighlightBoard" .. playerColor].call("showHighlight", hParams)
    end
  end
end

function oppositeColor(color)
  if color == "Blue" then
    return "Red"
  else
    return "Blue"
  end
end

function registerChoice(params)
  local playerColor = params.playerColor
  printToAll(getColoredName(playerColor) .. " made a choice.", "White")

  -- store choice
  choices[playerColor] = params
  _G["HighlightBoard" .. playerColor].call("hideAll", playerColor)

  -- hide "Play a Card" button
  _G["Playermat" .. playerColor].call("togglePlayButton")

  -- if both players made a choice, resolve them
  if choices.Blue ~= nil and choices.Red ~= nil then
    startLuaCoroutine(Global, "resolveBothCards")
  end
end

function resolveBothCards()
  -- get speed of players
  local speedBlue = _G["DeckmatBlue"].call("getSpeed")
  local speedRed = _G["DeckmatRed"].call("getSpeed")

  -- get round number
  local round = _G["RoundTracker"].getVar("val")
  local modifier = 0

  if round % 2 == 0 then
    -- even round: slower speed goes first
    modifier = -100
  else
    -- odd round: faster speed goes first
    modifier = 100
  end

  -- modify speed for movement before attack
  if isAttack(choices.Blue.cardId) then
    speedBlue = speedBlue + modifier
  end

  if isAttack(choices.Red.cardId) then
    speedRed = speedRed + modifier
  end

  if speedBlue > speedRed then
    printToAll(getColoredName("Red") .. "'s card gets resolved first.")
    resolveCard(choices.Red)
    coWait(1.5)
    resolveCard(choices.Blue)
  else
    printToAll(getColoredName("Blue") .. "'s card gets resolved first.")
    resolveCard(choices.Blue)
    coWait(1.5)
    resolveCard(choices.Red)
  end

  -- reset "choices" table
  choices = {}
  return 1
end

function coWait(t)
  local now = Time.time
  repeat coroutine.yield(0) until Time.time > now + t
end

function isAttack(cardId)
  return (METADATA[cardId].damage or 0) > 0
end

function resolveCard(params)
  local playerColor = params.playerColor
  local choiceGrid = params.choiceGrid

  -- get metadata
  local md = METADATA[params.cardId]
  local type = md.damage or 0

  -- get current position
  local grid = convertPosToGrid(_G["PlayerToken" .. playerColor].getPosition())

  -- get enemy position
  local enemyColor = oppositeColor(playerColor)
  local eGrid = convertPosToGrid(_G["PlayerToken" .. enemyColor].getPosition())

  -- early exit if token missing
  if not eGrid or not grid then
    broadcastToAll("Couldn't find both player tokens on the board.", "Red")
    return
  end

  if type > 0 then
    printToAll(getColoredName(playerColor) .. " played an attack card.")

    -- maybe deal damage to enemy
    local hitSomething = false

    -- display explosion
    local explosion = spawnObjectData({ data = explosionData, position = convertGridToPos(choiceGrid) })
    explosion.AssetBundle.playLoopingEffect(2)
    Wait.time(function() explosion.destruct() end, 2)

    -- check connected spaces
    local connectedTargets = getConnectedTargets(params.cardId, playerColor, choiceGrid)
    for _, target in ipairs(connectedTargets) do
      if eGrid.row == target.row and eGrid.col == target.col then
        _G["GamePanel"].call("dealDamageToColor", { color = enemyColor, damage = type })
        takeControlOfRelic(playerColor, false)
        hitSomething = true
        break
      end
    end

    -- attack missed
    if not hitSomething then
      broadcastToAll(getColoredName(playerColor) .. "'s attack missed (Row/Col: " .. choiceGrid.row .. "/" .. choiceGrid.col .. ")", "White")
    end
  else
    printToAll(getColoredName(playerColor) .. " played a movement card.")
    -- move action
    if eGrid.row == choiceGrid.row and eGrid.col == choiceGrid.col then
      broadcastToAll(getColoredName(playerColor) .. "'s movement was blocked (Row/Col: " .. choiceGrid.row .. "/" .. choiceGrid.col .. ")", "White")
    else
      _G["PlayerToken" .. playerColor].setPositionSmooth(convertGridToPos(choiceGrid))
      coWait(1)
      syncPrivateBoards()

      -- maybe take control of relic
      local relicGrid = convertPosToGrid(_G["Relic"].getPosition())
      if (choiceGrid.row == relicGrid.row and choiceGrid.col == relicGrid.col) then
        takeControlOfRelic(playerColor, true)
      end

      -- get next location for direction move
      if md.directionMove then
        -- get target location
        local newTarget = { row = 2 * choiceGrid.row - grid.row, col = 2 * choiceGrid.col - grid.col }

        -- if valid, repeat movement
        if validateTarget(newTarget, true, playerColor) then
          params.choiceGrid = newTarget
          coWait(1)
          resolveCard(params)
        end
      end
    end
  end

  -- discard active card
  _G["Playermat" .. playerColor].call("discardActiveCard")
end

-- Game Panel functions
function newGame()
  for _, obj in ipairs(getObjects()) do
    if obj.locked == false then
      obj.destruct()
    end
  end

  broadcastToAll("New Game!", "Green")

  for _, color in ipairs({ "Blue", "Red" }) do
    -- get new speed value for deckmats
    _G["Deckmat" .. color].call("setNewSpeed", math.random(1, 100))
  end

  -- set round to 0
  _G["RoundTracker"].call("updateVal", 0)

  -- newRound
  nextRound()
end

function nextRound()
  -- add 1 to round tracker
  local round = _G["RoundTracker"].call("addOrSubtract", 1)

  -- announce player that goes first
  local speedBlue = _G["DeckmatBlue"].call("getSpeed")
  local speedRed = _G["DeckmatRed"].call("getSpeed")

  local firstPlayer = "Blue"
  if round % 2 == 0 then
    -- even round: slower speed goes first
    if speedBlue < speedRed then
      firstPlayer = "Red"
    end
  else
    -- odd round: faster speed goes first
    if speedBlue >= speedRed then
      firstPlayer = "Red"
    end
  end

  broadcastToAll("---------", "Orange")
  broadcastToAll("Round " .. round, "Orange")
  broadcastToAll("---------", "Orange")
  broadcastToAll(getColoredName(firstPlayer) .. " goes first this round.")

  -- temporarily lock all cards and decks to exclude them from clean up
  for _, obj in ipairs(getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      obj.setLock(true)
      Wait.time(function() obj.setLock(false) end, 2)
    end
  end

  -- reset play area
  for _, obj in ipairs(searchLib.onObject(_G["PlayArea"], "isUnlocked")) do
    obj.destruct()
  end

  -- reset private playareas
  for _, obj in ipairs(searchLib.onObject(_G["PlayAreaBlue"], "isUnlocked")) do
    obj.destruct()
  end

  for _, obj in ipairs(searchLib.onObject(_G["PlayAreaRed"], "isUnlocked")) do
    obj.destruct()
  end

  -- reset turn tracker
  _G["TurnTracker"].call("updateVal", 1)

  -- spawn relic
  local relicGrid = { row = 3, col = math.random(5) }
  local yRotations = { 0, 90, 180, 270 }

  _G["Relic"] = _G["SourceRelic"].takeObject({
    position = convertGridToPos(relicGrid),
    rotation = { x = 0, y = yRotations[math.random(4)], z = 0 },
    smooth = false
  })
  GUID_LIST["Relic"] = _G["Relic"].getGUID()

  for _, color in ipairs({ "Blue", "Red" }) do
    local mat = _G["Playermat" .. color]

    -- reset playerboards
    for _, obj in ipairs(searchLib.onObject(mat, "isUnlocked")) do
      obj.destruct()
    end

    -- make sure all buttons are shown
    mat.call("createButtons")

    -- spawn player tokens
    _G["PlayerToken" .. color] = _G["SourcePlayerToken" .. color].takeObject({
      position = convertGridToPos(GridStart[color]),
      rotation = mat.getRotation(),
      smooth = false
    })
    GUID_LIST["PlayerToken" .. color] = _G["PlayerToken" .. color].getGUID()

    -- reset health trackers
    _G["HealthTracker" .. color].call("updateVal", 100)

    if round == 1 then
      -- give players copies of cards to assemble their deck
      local pos1 = Vector(direction[color] * 2.5, 0.2, 0)
      local pos2 = Vector(direction[color] * 3.5, 0.2, 0)
      local rot = mat.getRotation()
      _G["SourceMovementDeck"].takeObject({ position = mat.positionToWorld(pos1), rotation = rot })
      _G["SourceAttackDeck"].takeObject({ position = mat.positionToWorld(pos2), rotation = rot })
    end
  end

  syncPrivateBoards()

  if round == 1 then
    broadcastToAll("Assemble your deck from the provided piles (4 attack and 4 movement cards).", "White")
  end
end

function nextTurn()
  local turn = _G["TurnTracker"].call("addOrSubtract", 1)

  -- determine winner after 8 turns
  if turn == 9 then
    -- get current owner of relic
    local currentOwner

    local currentGrid = convertPosToGrid(_G["Relic"].getPosition())
    if currentGrid.row == 0 then
      currentOwner = "Blue"
    elseif currentGrid.row == 6 then
      currentOwner = "Red"
    end

    if currentOwner then
      -- someone owns the relic
      broadcastToAll(currentOwner .. " controls the relic at the end of turn 8.", "White")
      roundWin(currentOwner)
    else
      -- no relic control, higher HP wins
      local hpBlue = _G["HealthTrackerBlue"].getVar("val")
      local hpRed = _G["HealthTrackerRed"].getVar("val")

      if hpBlue > hpRed then
        broadcastToAll("Blue has more health the end of turn 8.", "White")
        roundWin("Blue")
      elseif hpRed > hpBlue then
        broadcastToAll("Red has more health the end of turn 8.", "White")
        roundWin("Red")
      else
        broadcastToAll("Players are tied at the end of turn 8 and the round ends in a draw.", "White")
      end
    end
  elseif turn > 9 then
    _G["TurnTracker"].call("addOrSubtract", -1)
    broadcastToAll("A round ends after 8 turns, press 'next Round' to proceed.", "White")
  else
    broadcastToAll("Turn " .. turn, "Yellow")

    -- show "Play a Card" button
    _G["PlayermatBlue"].call("togglePlayButton")
    _G["PlayermatRed"].call("togglePlayButton")
  end
end

-- re-sync boards if a tile is moved
function onObjectDrop(_, object)
  if object.type == "Tile" then
    Wait.time(syncPrivateBoards, 0.5)
  end
end

-- sync the private boards with the main play area
function syncPrivateBoards()
  for _, color in ipairs({ "Blue", "Red" }) do
    for _, tokenName in ipairs({ "Relic", "PlayerTokenBlue", "PlayerTokenRed" }) do
      -- make sure a copy of the token exists
      if not _G[tokenName .. "Copy" .. color] then
        _G[tokenName .. "Copy" .. color] = _G[tokenName].clone()
        GUID_LIST[tokenName .. "Copy" .. color] = _G[tokenName .. "Copy" .. color].getGUID()

        -- lock copy
        _G[tokenName .. "Copy" .. color].setLock(true)
        _G[tokenName .. "Copy" .. color].interactable = false

        -- half the scale
        local scale = _G[tokenName].getScale() * Vector(0.5, 1, 0.5)
        _G[tokenName .. "Copy" .. color].setScale(scale)
      end

      -- get position for token
      local publicPos = _G[tokenName].getPosition()
      local localPos = _G["PlayArea"].positionToLocal(publicPos)
      local copyPos = _G["PlayArea" .. color].positionToWorld(localPos):setAt("y", 2.8)

      -- move copies
      _G[tokenName .. "Copy" .. color].setPosition(copyPos)
      _G[tokenName .. "Copy" .. color].setRotation(_G[tokenName].getRotation())
    end
  end
end

function dealDamageToColor(params)
  local color = string.upper(params.color)
  local newHP = _G["HealthTracker" .. color].call("addOrSubtract", -1 * params.damage)
  broadcastToAll(params.color .. " lost " .. params.damage .. " health.", "White")

  if newHP == 0 then
    broadcastToAll(params.color .. " has been defeated.", "White")
    roundWin(oppositeColor(params.color))
  end
end

function roundWin(color)
  local round = _G["RoundTracker"].getVar("val")
  local score = _G["ScoreTracker" .. string.upper(color)].call("addOrSubtract", 1)

  if score == 2 then
    broadcastToAll(color .. " wins round " .. round .. " and the game!", "White")
  else
    broadcastToAll(color .. " wins round " .. round .. ".", "White")
  end

  -- advance to next round
  Wait.time(nextRound, 1)
end

function getColoredName(playerColor)
  local displayName = playerColor
  if Player[playerColor].steam_name then
    displayName = Player[playerColor].steam_name
  end

  -- add bb-code
  return "[" .. Color.fromString(playerColor):toHex() .. "]" .. displayName .. "[-]"
end

