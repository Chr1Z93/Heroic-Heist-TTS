require("libraries/GuidReferences")
local searchLib = require("libraries/SearchLib")

GRID_START_BLUE = { row = 1, col = 3 }
GRID_START_RED  = { row = 5, col = 3 }

function onLoad()
  getReferences()
  math.randomseed(os.time())

  -- shared parameters
  local buttonParameters = {
    function_owner = self,
    position = { x = 0, y = 0.2, z = 0 },
    height = 1350,
    width = 6000,
    scale = { 0.1, 0.1, 0.1 },
    font_size = 1000,
    font_color = { 0, 0, 0 }
  }

  -- new game button
  buttonParameters.label = "New Game"
  buttonParameters.click_function = "newGame"
  buttonParameters.position.z = -0.6
  buttonParameters.tooltip = "Click to start a new game"
  self.createButton(buttonParameters)

  -- next round button
  buttonParameters.label = "Next Round"
  buttonParameters.click_function = "nextRound"
  buttonParameters.tooltip = "Click to proceed to the next round"
  buttonParameters.position.z = 0
  self.createButton(buttonParameters)

  -- next turn button
  buttonParameters.label = "Next Turn"
  buttonParameters.click_function = "nextTurn"
  buttonParameters.tooltip = "Click to proceed to the next turn"
  buttonParameters.position.z = 0.6
  self.createButton(buttonParameters)
end

function getReferences()
  PLAYERMAT_BLUE       = getObjectFromName("PlayermatBlue")
  PLAYERMAT_RED        = getObjectFromName("PlayermatRed")

  DECKMAT_BLUE         = getObjectFromName("DeckmatBlue")
  DECKMAT_RED          = getObjectFromName("DeckmatRed")

  HEALTH_TRACKER_BLUE  = getObjectFromName("HealthTrackerBlue")
  HEALTH_TRACKER_RED   = getObjectFromName("HealthTrackerRed")

  ROUND_TRACKER        = getObjectFromName("RoundTracker")
  TURN_TRACKER         = getObjectFromName("TurnTracker")

  SCORE_TRACKER_BLUE   = getObjectFromName("ScoreTrackerBlue")
  SCORE_TRACKER_RED    = getObjectFromName("ScoreTrackerRed")

  SOURCE_PLAYER_BLUE   = getObjectFromName("SourcePlayerTokenBlue")
  SOURCE_PLAYER_RED    = getObjectFromName("SourcePlayerTokenRed")

  SOURCE_RELIC         = getObjectFromName("SourceRelic")
  SOURCE_ATTACK_DECK   = getObjectFromName("SourceAttackDeck")
  SOURCE_MOVEMENT_DECK = getObjectFromName("SourceMovementDeck")
  PLAYAREA             = getObjectFromName("PlayArea")
  PLAYAREA_BLUE        = getObjectFromName("PlayAreaBlue")
  PLAYAREA_RED         = getObjectFromName("PlayAreaRed")
end

function newGame()
  broadcastToAll("New Game!", "Green")

  for _, color in ipairs({ "BLUE", "RED" }) do
    -- get new speed value for deckmats
    _G["DECKMAT_" .. color].call("setNewSpeed", math.random(1, 100))
  end

  -- set round to 0
  ROUND_TRACKER.call("updateVal", 0)

  -- newRound
  nextRound()
end

function nextRound()
  -- add 1 to round tracker
  local round = ROUND_TRACKER.call("addOrSubtract", 1)

  -- announce player that goes first
  local speedBlue = DECKMAT_BLUE.call("getSpeed")
  local speedRed = DECKMAT_RED.call("getSpeed")

  local firstPlayer = "Blue"
  if round % 2 == 0 then
    -- even round: slower speed goes first
    if speedBlue >= speedRed then
      firstPlayer = "Red"
    end
  else
    -- odd round: faster speed goes first
    if speedBlue < speedRed then
      firstPlayer = "Red"
    end
  end

  broadcastToAll("Round " .. round, "Orange")
  broadcastToAll(firstPlayer .. " goes first this round.", firstPlayer)

  -- temporarily lock all cards and decks to exclude them from clean up
  for _, obj in ipairs(getObjects()) do
    if obj.type == "Card" or obj.type == "Deck" then
      obj.setLock(true)
      Wait.time(function() obj.setLock(false) end, 2)
    end
  end

  -- reset play area
  for _, obj in ipairs(searchLib.onObject(PLAYAREA, "isUnlocked")) do
    obj.destruct()
  end

  -- reset private playareas
  for _, obj in ipairs(searchLib.onObject(PLAYAREA_BLUE, "isUnlocked")) do
    obj.destruct()
  end

  for _, obj in ipairs(searchLib.onObject(PLAYAREA_RED, "isUnlocked")) do
    obj.destruct()
  end

  -- reset turn tracker
  TURN_TRACKER.call("updateVal", 1)

  -- spawn relic
  local relicGrid = { row = 3, col = math.random(5) }
  local yRotations = { 0, 90, 180, 270 }

  SOURCE_RELIC.takeObject({
    position = Global.call("convertGridToPos", relicGrid),
    rotation = { x = 0, y = yRotations[math.random(4)], z = 0 }
  })

  for _, color in ipairs({ "BLUE", "RED" }) do
    local mat = _G["PLAYERMAT_" .. color]

    -- reset playerboards
    for _, obj in ipairs(searchLib.onObject(mat, "isUnlocked")) do
      obj.destruct()
    end

    -- make sure all buttons are shown
    mat.call("createButtons")

    -- spawn player tokens
    _G["SOURCE_PLAYER_" .. color].takeObject({
      position = Global.call("convertGridToPos", _G["GRID_START_" .. color]),
      rotation = mat.getRotation()
    })

    -- reset health trackers
    _G["HEALTH_TRACKER_" .. color].call("updateVal", 100)

    if round == 1 then
      -- give players copies of cards to assemble their deck
      local direction = { BLUE = -1, RED = 1 }
      local pos1 = Vector(direction[color] * 2.5, 0.2, 0)
      local pos2 = Vector(direction[color] * 3.5, 0.2, 0)
      local rot = mat.getRotation()
      SOURCE_MOVEMENT_DECK.takeObject({ position = mat.positionToWorld(pos1), rotation = rot })
      SOURCE_ATTACK_DECK.takeObject({ position = mat.positionToWorld(pos2), rotation = rot })
    end
  end

  if round == 1 then
    broadcastToAll("Assemble your deck from the provided piles (4 from each).", "White")
  end
end

function nextTurn()
  local turn = TURN_TRACKER.call("addOrSubtract", 1)

  -- determine winner after 8 turns
  if turn == 9 then
    -- get current owner of relic
    local currentOwner

    for _, obj in ipairs(getObjects()) do
      if obj.getName() == "Relic" then
        local currentGrid = Global.call("convertPosToGrid", obj.getPosition())
        if currentGrid.row == 0 then
          currentOwner = "Blue"
        elseif currentGrid.row == 6 then
          currentOwner = "Red"
        end
        break
      end
    end

    if currentOwner then
      -- someone owns the relic
      broadcastToAll(currentOwner .. " controls the relic at the end of turn 8.", "White")
      roundWin(currentOwner)
    else
      -- no relic control, higher HP wins
      local hpBlue = HEALTH_TRACKER_BLUE.getVar("val")
      local hpRed = HEALTH_TRACKER_RED.getVar("val")

      if hpBlue > hpRed then
        broadcastToAll("Blue has more health the end of turn 8.", "White")
        roundWin("Blue")
      elseif hpRed > hpBlue then
        broadcastToAll("Red has more health the end of turn 8.", "White")
        roundWin("Red")
      else
        broadcastToAll("Players are tied at the end of turn 8 and the round ends in a draw.", "White")
      end
    end
  elseif turn > 9 then
    TURN_TRACKER.call("addOrSubtract", -1)
    broadcastToAll("A round ends after 8 turns, press 'next Round' to proceed.", "White")
  else
    broadcastToAll("Turn " .. turn, "Yellow")

  -- show "Play a Card" button
  PLAYERMAT_BLUE.call("togglePlayButton")
  PLAYERMAT_RED.call("togglePlayButton")
  end
end

function dealDamageToColor(params)
  local color = string.upper(params.color)
  local newHP = _G["HEALTH_TRACKER_" .. color].call("addOrSubtract", -1 * params.damage)
  broadcastToAll(params.color .. " lost " .. params.damage .. " health.", "White")

  if newHP == 0 then
    broadcastToAll(params.color .. " has been defeated.", "White")
    roundWin(oppositeColor(params.color))
  end
end

function roundWin(color)
  local round = ROUND_TRACKER.getVar("val")
  local score = _G["SCORE_TRACKER_" .. string.upper(color)].call("addOrSubtract", 1)

  if score == 2 then
    broadcastToAll(color .. " wins round " .. round .. " and the game!", "White")
  else
    broadcastToAll(color .. " wins round " .. round .. ".", "White")
  end

  -- advance to next round
  Wait.time(nextRound, 1)
end

function oppositeColor(color)
  if color == "Blue" then
    return "Red"
  else
    return "Blue"
  end
end
